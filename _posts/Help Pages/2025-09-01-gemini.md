---
layout: post 
show_reading_time: false
permalink: /layoutdocument
title: Layouts Final
categories: [Help Pages]
---



# Documentation for Coding Lesson Layouts

This documentation outlines how to use the provided HTML files (`cover.html` and `lesson.html`) to create interactive and engaging coding lessons for students.

## 1. `lesson.html`: The Basic Lesson Layout

This file provides the fundamental structure for all your coding lessons. It includes styling and basic functionalities.

### Structure

* **HTML Structure:** Defines the basic HTML structure with a style section and a content area.
* **CSS Styling:** Includes CSS to style the lesson content, ensuring readability and a consistent look. Key styles include:
    * `#lesson-content`: Styles the main content area, ensuring text is selectable and handles pointer events. Sets up margins, font, and line height.
    * `pre`: Styles code blocks with a background color, padding, and border-radius for visual distinction.
    * `code`: Styles inline code snippets with a monospace font and a distinct color.
    * `body`: Sets the background color to black.
* **JavaScript Functionality:**
    * **Animations:** Animates sections as they load, creating a dynamic user experience.
    * **Local Storage:** Manages local storage for the "Popcorn Hack" feature, saving and loading student responses.
    * **Button Interactions:** Adds hover and interaction effects to buttons for enhanced usability.
    * **Code Execution:** Includes functions to run code snippets (JavaScript and Python) within the lesson.
    * **Feedback Poll:** Implements a feedback poll to gather student opinions.
    * **Data View Toggle:** Allows teachers to toggle the visibility of response data.
    * **Data Refresh:** Provides a mechanism to refresh the displayed data.
    * **Auto-Refresh:** Automatically refreshes data at set intervals.

### How to Use `lesson.html`

1.  **Base Template:** This file serves as the base template for all your lessons. Do not directly modify this file unless you intend to change the global style or the basic structure of all lessons.
2.  **Content Injection:** The `{{ content }}` placeholder is where the specific content of each lesson will be inserted. This is typically done by including other HTML files (like the features in `cover.html`) or by directly adding HTML content when creating a lesson.
3.  **Customization:** The `<style>` block can be modified to adjust the overall look of the lessons. However, for lesson-specific styling, it's recommended to use inline styles or separate CSS files included within the lesson content.
4.  **JavaScript Functions:** The JavaScript code provides interactivity. Customize or extend these functions as needed for specific lesson requirements.

## 2. `cover.html`: A Sample Lesson with Features

This file demonstrates how to build a complete lesson using `lesson.html` as a base and incorporating various interactive features.

### Structure

* **Frontmatter:** Uses YAML-style frontmatter to define metadata for the lesson:
    * `layout: lesson`: Specifies that this lesson uses the `lesson.html` layout.
    * `title`: Sets the title of the lesson ("Introduction to Functions").
    * `video_url`: Provides a URL for an introductory video.  This URL `https://www.youtube.com/watch?v=zvzjaqMBEso` is a placeholder. You'll need to replace this with an actual YouTube video URL.
    * `hack_prompt`:  Sets the prompt for the "hack" activity.
    * `permalink`: Defines the URL for this lesson.
* **Lesson Content:** Contains the actual content of the lesson, including:
    * Introduction to functions with explanations and examples.
    * Interactive elements included via `{% include ... %}` directives:
        * `whiteboard.html`:  (Not provided, but assumed to be a whiteboard feature for interactive drawing or writing).
        * `video.html`: (Not provided, assumed to be a video player, likely using the `video_url` from the frontmatter).
        * `ai_comprehension.html`: (Not provided, assumed to be a feature that uses AI to check student comprehension).
        * `hack.html`: (Not provided, assumed to be a coding challenge or exercise, likely using the `hack_prompt` from the frontmatter).
        * `flashcards.html`: (Not provided, assumed to be a flashcard feature for vocabulary or concept review).
        * `flashcard-notes.html`: (Not provided, assumed to be a feature for students to take notes on flashcards).
        * `game.html`: (Not provided, assumed to be a coding game or activity).
        * `poll.html`: (Uses the feedback poll functionality defined in `lesson.html`).
* **Sidebar:** Includes `slim_sidebar.html` (not provided), likely a navigation or additional information panel.

### How to Use `cover.html` as a Template

1.  **Start with `cover.html`:** This file gives a good example of how to structure a lesson.
2.  **Customize Content:** Modify the HTML within the `<div id="lesson-content">` to fit your specific lesson topic.  Replace the example content with your own explanations, examples, and instructions.
3.  **Include Features:** Use the `{% include ... %}` directives to add the desired interactive features.  You will need to create or obtain the HTML files for these features (e.g., `whiteboard.html`, `video.html`, etc.).
4.  **Set Frontmatter:** Adjust the frontmatter at the top of the file:
    * `title`: Change the lesson title.
    * `video_url`:  Provide the correct URL for your introductory video.
    * `hack_prompt`:  Write a relevant prompt for the coding challenge.
    * `permalink`:  Set the desired URL for the lesson.
5.  **Create Feature Files:** Ensure that the HTML files you are including (e.g., `whiteboard.html`, `video.html`) exist and contain the code for the interactive elements you want to use. You'll need to develop these files according to the functionality you envision.
6.  **Sidebar:** If you have a sidebar, create or modify `slim_sidebar.html` to contain the desired content.

### Creating a New Lesson

1.  **Copy `cover.html`:** Start by making a copy of `cover.html` and renaming it to something relevant to your new lesson (e.g., `arrays.html`).
2.  **Customize:** Follow the steps outlined in "How to Use `cover.html` as a Template" to adapt the content, features, and frontmatter to your new lesson.

This documentation should provide a solid foundation for teachers to begin creating interactive coding lessons using the provided HTML files. Remember that you will need to develop the HTML files for the included features to make them fully functional.











---
# Feature Documentation: Live Whiteboard Viewer (`whiteboard.html`)

This documentation explains how teachers can leverage the `whiteboard.html` feature to integrate live, interactive whiteboards into their coding lessons. This feature allows teachers to use an external whiteboard website, with student screens updating in real-time.

## Overview

The `whiteboard.html` file provides an embedded live whiteboard experience for students. Teachers can share a unique "board code" from an external whiteboard platform (e.g., `whiteboard.team`), and students can enter this code to view the teacher's live drawing and annotations. This fosters an interactive learning environment where visual explanations can be shared seamlessly.

## How the Teacher Uses This Feature

1.  **Select an External Whiteboard Service:** This feature is designed to work with an external live whiteboard service. The current implementation is configured for `whiteboard.team`.
    * **Teacher Action:** The teacher will need to go to their chosen external whiteboard website (e.g., `https://www.whiteboard.team/`) and create or open a board.
2.  **Obtain the Board Code:** Most live whiteboard services provide a unique identifier or shareable link for each board.
    * **Teacher Action:** Locate the **board code** from the URL of your active whiteboard session. For `whiteboard.team`, this is the alphanumeric string after `/board/` in the URL (e.g., in `https://www.whiteboard.team/app/board/svVDABAW`, the code is `svVDABAW`).
3.  **Integrate into Your Lesson (`cover.html`):** To make the whiteboard feature available in a lesson, you need to include it using a Liquid tag in your lesson's markdown or HTML file (like `cover.html`).
    * **Teacher Action:** Add the following line where you want the whiteboard viewer to appear in your lesson content:
        ```html
        {% include whiteboard.html %}
        ```
        This line tells the system to pull in the content of `whiteboard.html` at that spot.
4.  **Initiate the Whiteboard Session during the Lesson:** During the live lesson, both the teacher (if using a student-like view) and students will see the whiteboard viewer.
    * **Teacher Action (and Student Action):** In the "Board Code" input field within the `whiteboard.html` section, enter the **board code** you obtained from your external whiteboard service.
    * **Teacher Action (and Student Action):** Click the **"Load Whiteboard"** button. The embedded whiteboard will then load, displaying the live content from your shared board.

## Key Functionalities for Teachers and Students

* **Live Updates:** Once the board code is loaded, the embedded whiteboard will update in real-time as the teacher draws or writes on their external whiteboard.
* **Intuitive Interface:** The viewer includes a clear input field for the board code and prominent buttons to load or clear the whiteboard.
* **Loading State:** A "Loading whiteboard..." message with a spinner appears while the whiteboard content is being fetched, providing user feedback.
* **Fullscreen Mode:** After loading, the whiteboard automatically expands to a fullscreen view, maximizing space for content and interaction.
* **Sidebar Toggle:** A sidebar toggle button (`<i class="fas fa-chevron-left"></i>`) is available to hide/show the input sidebar. This is useful for maximizing the whiteboard viewing area once the board is loaded.
* **"New Board" / Restart Session:** A **"New Board"** button (`<i class="fas fa-redo"></i>`) appears in fullscreen mode.
    * **Teacher Action:** If you want to start a completely new session or correct an entered code, click this button. It will clear the current whiteboard, hide the fullscreen view, and bring back the input sidebar, allowing you to enter a different board code.
* **Error Handling:** Basic validation checks for the board code and displays status messages for success or errors (e.g., "Invalid board code format" or "Failed to load whiteboard").
* **Responsive Design:** The layout adjusts for different screen sizes, ensuring a good experience on various devices.

## Best Practices for Teachers

* **Pre-test Your Board:** Before the lesson, ensure your chosen external whiteboard service is working correctly and that you can successfully obtain and load your board code within the `whiteboard.html` viewer.
* **Clear Instructions:** Provide students with clear instructions on where to find the "Board Code" input field and how to enter the code you provide.
* **Share the Code Clearly:** When sharing the board code, display it prominently on the main screen and perhaps in the chat for students to easily copy.
* **Leverage Fullscreen:** Encourage students to use the fullscreen mode to get the best view of your whiteboard content. The system does this automatically once loaded.
* **Use the "New Board" Feature:** If a board code is entered incorrectly, or you wish to transition to a completely new visual explanation during the lesson, the "New Board" button provides a quick way to reset and load a different board.

This `whiteboard.html` feature offers a dynamic and interactive way to enhance your coding lessons with live visual explanations, making complex concepts easier for students to grasp.







# Feature Documentation

---

## Embedded YouTube Video Viewer

This documentation explains how the embedded YouTube video viewer feature can be integrated into your coding lessons. This allows teachers to seamlessly include relevant YouTube videos directly within the lesson content for students to watch and learn from.

### Overview
- Creates a visually appealing, functional in-page YouTube video player.
- Designed to be embedded directly within lesson content (e.g., `cover.html` or other lesson files).
- Fetches the YouTube video ID from the lesson's frontmatter and displays the video in a styled container.

### How the Teacher Uses This Feature
1. **Obtain the YouTube Video URL**  
   Find the YouTube video you want to include in your lesson. Copy the full URL.

2. **Extract the Video ID**  
   The video ID is usually found after `v=` in the URL.  
   Example:  
https://www.youtube.com/watch?v=dQw4w9WgXcQ
Video ID: dQw4w9WgXcQ

yaml
Copy
Edit

3. **Add `video_url` to Frontmatter**  
In the frontmatter of your lesson file (e.g., `cover.html`), add a `video_url` field with the extracted video ID.

```yaml
---
layout: lesson
title: Your Awesome Lesson
video_url: dQw4w9WgXcQ
# ... other frontmatter ...
---
Include the Video Viewer in Lesson Content
Insert the provided HTML snippet where you want the video to appear in the lesson body.

Key Functionalities for Teachers and Students
In-Page Playback: Video plays embedded within the lesson page; no need to navigate away.

Styled Container: Gradient background, subtle animations, stylized header for visual appeal.

Responsive Design: Video iframe maintains aspect ratio and scales across screen sizes.

HD Indicator: Displays a small "HD" badge indicating high-definition availability.

Descriptive Text: Includes a small text element "Expand your knowledge" for context.

Fullscreen Option: allowfullscreen attribute enables fullscreen video playback.

Best Practices for Teachers
Relevance: Ensure the video is directly relevant and enhances lesson understanding.

Conciseness: Prefer concise videos that effectively convey key information.

Accessibility: Consider providing a brief summary of the video content for accessibility.

Test Embedding: Preview lessons after embedding to verify correct video loading and playback.

AI Comprehension Checker
This documentation explains how the AI Comprehension Checker helps students review their understanding of lesson content through AI-generated questions, useful for self-assessment and exam prep.

Overview
Provides an interactive interface for students to request AI-generated questions based on the current lesson.

Uses the Groq API (llama3-8b-8192 model) to generate multiple-choice or short-answer questions with selectable difficulty.

Students attempt answers and receive immediate AI-generated feedback.

How Students Use This Feature
Access the Comprehension Checker
Found within the lesson page under the "AI Comprehension Checker" section.

Select Question Preferences

Question Type: Choose between "Multiple Choice" or "Short Answer".

Difficulty Level: Select difficulty — Easy, Medium, or Hard.

Generate a Question
Click the "Generate Question" button to request a question from the AI based on lesson content and preferences.

Attempt to Answer

Multiple Choice: Select your answer by clicking the corresponding radio button.

Short Answer: Type your answer in the provided text input field.

Check the Answer
Click the "Check Answer" button.

For multiple choice: Immediate feedback if correct or incorrect with explanation.

For short answer: AI evaluates the answer, providing acceptability feedback and a sample correct answer.

Get a New Question
Click "New Question" to generate additional questions.

Key Functionalities for Students
AI-Powered Question Generation: Dynamic question creation based on lesson content.

Customizable Question Type and Difficulty: Tailor review sessions.

Immediate Feedback: Clear and detailed correctness feedback.

Multiple Choice Questions: Clearly presented questions with labeled options.

Short Answer Evaluation: Nuanced AI feedback on free-text answers.

Tracking Asked Questions: Attempts to avoid repeating recently asked questions.

User-Friendly Interface: Clear labels, buttons, and feedback messages.

Engaging Visuals: Card-based layout with animations and thematic brain icon.

Technical Considerations (for Teachers)
API Key: Replace the placeholder Groq API key with your valid key that has access to llama3-8b-8192.

Lesson Content Extraction: The script extracts lesson text from an element with ID lesson-content. Ensure this element exists.

JSON Parsing: AI returns data in specific JSON format; errors will display a message.

Error Handling: Basic handling for API and JSON errors is implemented.

Best Practices for Students
Review Lesson Content First: Use after studying the lesson.

Experiment with Question Types and Difficulties: Test understanding with different formats and challenge levels.

Read Feedback Carefully: Use feedback to identify learning gaps.

Don't Rely Solely on AI: Use as a supplement, not a replacement for active learning.

Report Issues: Inform teachers if the feature malfunctions.

The AI Comprehension Checker offers a dynamic, personalized review experience that supports deeper engagement with lesson materials and prepares students effectively for assessments.

Copy
Edit













# Feature Documentation: Popcorn Hack (Interactive Lesson Prompts)

This documentation details the **Popcorn Hack** feature, an interactive element for coding lessons designed to engage students with questions or coding prompts provided by the teacher. Students can input their answers or code, and if it's a coding prompt, they can execute their code in either Python or JavaScript. Their responses are stored locally in the browser.

## Overview

The Popcorn Hack component creates a sleek, interactive "hack" prompt directly within your lesson content. It's configured to display a teacher-defined question or coding challenge, provide an input area, and allow for code execution for Python and JavaScript, all while maintaining local storage of student responses.

## How the Teacher Uses This Feature

1.  **Define the Prompt:** In the **frontmatter (YAML)** of your lesson file (e.g., `cover.html` or a sample lesson file), add a `hack_prompt` field. Set its value to the question or coding challenge you want students to address.

    *Example Frontmatter:*

    ```yaml
    ---
    layout: lesson
    title: Introduction to Loops
    hack_prompt: "Write a Python function that calculates the factorial of a number."
    ---
    ```

2.  **Include the Popcorn Hack Component:** Embed the provided HTML snippet for the Popcorn Hack directly into your lesson's content file where you want the prompt to appear.

## How Students Use This Feature

1.  **View the Prompt:** Students will see the "Popcorn Hack" section with the question or coding challenge defined by the teacher.
2.  **Select Language (for coding prompts):** If the prompt requires code, students can choose between "JavaScript" and "Python" using the dropdown selector.
3.  **Enter Response/Code:** Students type their answer or code into the provided textarea.
4.  **Save Response:** Clicking the "**Save Response**" button will locally store their current input in their browser's local storage. This means their work will persist even if they close and reopen the lesson.
5.  **Clear Response:** The "**Clear**" button allows students to erase their current input in the textarea.
6.  **Run Code (for coding prompts):** If they've entered code, clicking the "**Run Code**" button will execute their code in the selected language. The output (or any errors) will be displayed in the output box below the buttons.

## Key Functionalities

* **Teacher-Defined Prompts:** Teachers can easily customize each "hack" question or coding challenge via the lesson's frontmatter.
* **Local Storage:** Student responses are automatically saved in their browser's local storage, ensuring their progress isn't lost.
* **Multi-Language Code Execution:** Supports running code in both **Python** (via Pyodide) and **JavaScript**, making it versatile for different programming lessons.
* **Interactive UI:** Features a user-friendly interface with clear buttons for saving, clearing, and running code.
* **Visual Feedback:** Provides status messages (e.g., "Response saved successfully!") to confirm actions.

---

# Feature Documentation: Teacher-Provided Flashcards

This documentation explains how the **Teacher-Provided Flashcards** feature works, allowing teachers to create and provide sets of flashcards for students to practice terms and definitions. This feature is great for quick reviews and reinforcing key concepts.

## Overview

This feature displays a deck of flashcards, pulling terms and definitions from a YAML data file (`flashcards.yml`). Students can flip cards, mark them as "Known" or "Review Again," and navigate through the deck. A sidebar also shows cards marked for review, offering a quick way to jump to specific cards.

## How the Teacher Uses This Feature

1.  **Create/Edit `flashcards.yml`:** In your project's `_data` directory, ensure you have a `flashcards.yml` file. This file will contain an array of card objects, each with a `term` and a `definition`.

    *Example `flashcards.yml`:*

    ```yaml
    cards:
      - term: Loop
        definition: A programming structure that repeats a block of code.
      - term: Iteration
        definition: Each time a loop runs.
      - term: For Loop
        definition: A loop that repeats a fixed number of times.
      - term: While Loop
        definition: A loop that continues as long as a condition is true.
      - term: Infinite Loop
        definition: A loop that never stops because the condition is always true.
      - term: Break
        definition: A command that stops the loop before it finishes normally.
      - term: Continue
        definition: A command that skips the current loop iteration and moves to the next.
      - term: Range
        definition: A function used with for loops to specify how many times to repeat.
      - term: Nested Loop
        definition: A loop inside another loop.
      - term: Condition
        definition: An expression that evaluates to true or false, used in while loops.
      - term: Index
        definition: The position number of an item in a list, often used in loops.
      - term: Loop Variable
        definition: A variable that changes value in each iteration of the loop.
    ```

2.  **Include the Flashcards Component:** Insert the `flashcards.html` include tag into your lesson content where you want the flashcards to appear.

    *Example in a lesson file:*

    ```html
    {% include flashcards.html %}
    ```

## How Students Use This Feature

1.  **Navigate Flashcards:** Students can use the "Previous" and "Next" buttons to move through the flashcard deck.
2.  **Flip Cards:** Clicking the "**Flip Card**" button (or the card itself) will reveal the definition on the back of the card. Clicking again flips it back to the term.
3.  **Mark for Review:** After reviewing a card, students can click:
    * "**I Know This**": Marks the card as understood. A green status message will appear.
    * "**Review Again**": Marks the card for later review. A yellow status message will appear, and the card's term will be added to the "Marked for Review" sidebar.
4.  **Track Progress:** A progress bar at the top indicates how many cards they've marked as "known."
5.  **Review Sidebar:** The "Marked for Review" sidebar displays a list of terms that students have marked for review. Clicking on a term in this list will jump directly to that flashcard in the deck.

## Key Functionalities

* **YAML-Driven Content:** Teachers can easily define flashcard terms and definitions in a structured `flashcards.yml` file.
* **Interactive Flipping:** Cards flip with a smooth animation to reveal answers.
* **Progress Tracking:** A visual progress bar helps students monitor their learning progress.
* **Review Management:** Students can mark cards for review, and these are listed in a separate sidebar for easy access.
* **Local Storage for Progress:** The student's progress (known cards, review cards, current card index) is saved in their browser's local storage, so they can continue where they left off.
* **Spaced Repetition (Basic):** The system has a basic spaced repetition mechanism that, on a new day, can move "known" cards back into the review queue based on an increasing interval, encouraging periodic re-engagement.

---

# Feature Documentation: Flashcard Notes (Student-Created Flashcards)

This documentation outlines the **Flashcard Notes** feature, which empowers students to create, edit, and practice their own flashcards as a form of note-taking. This personal set of flashcards is stored locally in their browser.

## Overview

The Flashcard Notes component provides an interactive interface for students to create custom flashcards (term and definition). They can then review these cards using a carousel, flip them, and track their progress. Since this is a personal note-taking tool, all data is stored locally in the student's browser.

## How Students Use This Feature

1.  **Access Flashcard Notes:** Students navigate to the page containing the `flashcard-notes.html` component.
2.  **Create New Flashcards:**
    * Students type a **Term** in the first input field.
    * They type the corresponding **Definition** in the textarea.
    * Clicking "**Save Flashcard**" adds the new card to their personal deck.
3.  **Edit Existing Flashcards:** When a flashcard is currently displayed in the carousel, its term and definition will populate the input fields. Students can modify these fields and click "**Save Flashcard**" to update the existing card.
4.  **Practice Flashcards:**
    * **Navigation:** Use the "← Prev" and "Next →" buttons to move through their created flashcards.
    * **Flip Card:** Click anywhere on the flashcard to flip it between the term and definition.
    * **Progress Tracking:** A progress bar and counter (`X / Y`) show their progress through their self-created deck.
5.  **Mark Cards (Implicit):** While there isn't an explicit "know" or "review" button as in the teacher-provided flashcards, the act of cycling through their self-created cards and flipping them serves as a review mechanism. The local storage ensures they can pick up where they left off.

## Key Functionalities

* **Student-Centric Note-Taking:** Empowers students to create personalized study materials.
* **Local Data Storage:** All student-created flashcards are stored directly in their browser's local storage, ensuring privacy and persistence for individual users.
* **Create and Edit:** Students have full control to add new flashcards or modify existing ones.
* **Interactive Carousel:** A visual carousel allows students to seamlessly cycle through their flashcards.
* **Flip Functionality:** Cards can be flipped to reveal the term or definition.
* **Progress Visualization:** A progress bar and numeric counter help students track how many cards they've created and reviewed.
* **Efficient Alternative to Traditional Notes:** Positions flashcard creation as a dynamic and effective alternative to traditional note-taking methods like Cornell notes.











# Multiplayer Quiz Game Feature Documentation

This document outlines the implementation and functionality of the multiplayer multiple-choice quiz game, designed to allow students to evaluate their knowledge through an interactive and competitive experience. The game utilizes `socket.io` for real-time communication, a Flask backend for server-side logic, and YAML for question management.

## Table of Contents

1.  [Introduction](#introduction)
2.  [Features](#features)
3.  [Technical Stack](#technical-stack)
4.  [File Structure](#file-structure)
5.  [Setup and Installation](#setup-and-installation)
6.  [Usage](#usage)
    * [Teacher (Question Management)](#teacher-question-management)
    * [Student (Playing the Game)](#student-playing-the-game)
7.  [Code Explanation](#code-explanation)
    * [game.html (Frontend)](#gamehtml-frontend)
    * [main.py (Backend)](#mainpy-backend)
    * [game_questions.yml (Content)](#game_questionsyml-content)
8.  [Socket.IO Events](#socketio-events)
9.  [Styling](#styling)
10. [Future Enhancements](#future-enhancements)

## 1. Introduction

The multiplayer quiz game is an engaging tool for students to test their understanding of specific topics. It features a multiple-choice format, a countdown timer for each question, and a real-time leaderboard to foster a competitive learning environment. Teachers can easily customize the quiz content by modifying a simple YAML file.

## 2. Features

* **Multiplayer Capability:** Students can join the same game session and compete against each other.
* **Real-time Leaderboard:** Scores are updated and displayed in real-time as players answer questions.
* **Multiple Choice Questions:** Presents questions with predefined options.
* **Timed Questions:** Each question has a time limit, encouraging quick thinking.
* **Score Calculation:** Points are awarded based on correct answers and speed.
* **Difficulty Levels:** Players can choose between Easy, Medium, and Hard, which adjusts the time per question.
* **Quiz Progression:** A progress bar visually indicates the player's advancement through the quiz.
* **Result Summary:** Displays the number of correct answers, wrong answers, and total points at the end of the quiz.
* **Easy Content Management:** Quiz questions are defined in a separate YAML file, allowing for simple updates by teachers.

## 3. Technical Stack

* **Frontend:**
    * HTML5
    * CSS3 (custom styles for a "glassmorphism" effect)
    * JavaScript
    * Socket.IO Client Library
    * Font Awesome (for icons)
* **Backend:**
    * Python (Flask framework)
    * Flask-SocketIO
* **Content Management:**
    * YAML (`game_questions.yml`)

## 4. File Structure

.
├── game.html
├── main.py
└── _data
└── game_questions.yml


* `game.html`: The main frontend HTML file containing the quiz interface and JavaScript logic.
* `main.py`: The Flask backend server handling Socket.IO connections and game logic.
* `_data/game_questions.yml`: A YAML file that stores all the quiz questions, options, and correct answers.

## 5. Setup and Installation

To set up and run the quiz game, follow these steps:

1.  **Prerequisites:**
    * Python 3.x installed
    * `pip` (Python package installer)

2.  **Clone the Repository (if applicable):**
    ```bash
    git clone <repository_url>
    cd <repository_name>
    ```

3.  **Install Python Dependencies:**
    ```bash
    pip install Flask Flask-SocketIO pyyaml
    ```

4.  **Configure CORS (if deploying):**
    In `main.py`, ensure `cors_allowed_origins` in the `SocketIO` initialization includes the domain(s) where your `game.html` will be hosted.
    ```python
    socketio = SocketIO(app, cors_allowed_origins=[
        "[https://hypernova101.github.io](https://hypernova101.github.io)",
        "http://localhost:8000",
        "[http://127.0.0.1:8000](http://127.0.0.1:8000)",
        "[https://adik1025.github.io](https://adik1025.github.io)"
    ])
    ```
    Add your deployment URL (e.g., your GitHub Pages URL) to this list. For local development, `http://localhost:8000` or `http://127.0.0.1:8000` is sufficient.

5.  **Run the Flask Backend:**
    ```bash
    python main.py
    ```
    The server will typically run on `http://127.0.0.1:5000` by default.

6.  **Open `game.html`:**
    You can open `game.html` directly in your web browser, or serve it through a simple web server (e.g., using Python's `http.server` for testing: `python -m http.server 8000`).
    **Important:** Ensure the `socket.io` client in `game.html` connects to the correct Flask server address.
    ```javascript
    const socket = io("[https://flask.opencodingsociety.com](https://flask.opencodingsociety.com)"); // Update this if your Flask server is elsewhere
    ```

## 6. Usage

### Teacher (Question Management)

Teachers can manage the quiz content by editing the `_data/game_questions.yml` file.

**`_data/game_questions.yml` Structure:**

The YAML file contains a list of questions, each with the following properties:

* `question`: The text of the quiz question.
* `options`: A list of possible answer choices.
* `correct_answer`: The exact string of the correct answer, which must match one of the `options`.

**Example:**

```yaml
questions:
  - question: "What type of loop is best when you know how many times you want to repeat?"
    options:
      - "While loop"
      - "Do-while loop"
      - "For loop"
      - "If statement"
    correct_answer: "For loop"

  - question: "What happens if a while loop’s condition never becomes false?"
    options:
      - "The program crashes"
      - "It creates an infinite loop"
      - "It stops automatically"
      - "It returns an error"
    correct_answer: "It creates an infinite loop"
To update questions:

Open _data/game_questions.yml in a text editor.
Add, modify, or remove question entries following the specified structure.
Save the file.
Restart the Flask backend (main.py) for changes to take effect on the server.
Student (Playing the Game)
Access the Game: Open game.html in your web browser.
Enter Name and Difficulty:
Type your desired player name in the "Your Name" field.
Select a difficulty level (Easy, Medium, Hard) from the dropdown. This determines the time allowed per question.
Start Quiz: Click the "Start Quiz" button.
Answer Questions:
Read the question and select one of the provided options by clicking on it.
A countdown timer will indicate the remaining time. Answering faster gives more points.
After answering or if time runs out, feedback (correct/wrong) will be displayed, and the correct answer will be highlighted.
View Leaderboard:
On the login screen, click "View Leaderboard" to see the live scores of all active players.
Click "Hide Leaderboard" to close it.
Quiz Completion:
Once all questions are answered, the "Quiz Completed!" screen will show your total correct answers, wrong answers, and points.
The overall leaderboard will also be displayed.
Play Again: Click the "Play Again" button to return to the login screen and start a new game.
7. Code Explanation
game.html (Frontend)
Jekyll Integration ({% assign questions = site.data.game_questions.questions %}): This line suggests that game.html is part of a Jekyll site. It dynamically loads questions from _data/game_questions.yml into a JavaScript array quizQuestions.
Styling (<style> block): Defines the visual appearance of the quiz, utilizing a "glassmorphism" aesthetic with transparent backgrounds, blurs, and subtle shadows.
HTML Structure:
quiz-login: Initial screen for player name and difficulty selection.
active-quiz: Displays the current question, options, and countdown timer.
quiz-results: Shows quiz summary and the final leaderboard.
progress-bar: Visual indicator of quiz completion.
JavaScript Logic:
Socket.IO Connection:
JavaScript

const socket = io("[https://flask.opencodingsociety.com](https://flask.opencodingsociety.com)"); // Connects to the Flask backend
initQuiz(): Resets game state (score, question index), sets timer duration based on difficulty, and transitions to the active quiz screen.
loadQuestion():
Updates the question counter and progress bar.
Displays the current question text.
Dynamically creates option elements, attaching event listeners for selectOption.
Calls startTimer().
startTimer(): Manages the countdown, updates the timer display, and applies warning or danger classes to the countdown circle based on remaining time. Calls timeUp() when the timer reaches zero.
timeUp(): Handles scenarios where the player doesn't answer in time. It disables options, highlights the correct answer, updates wrongAnswers, and proceeds to the next question after a delay.
selectOption(optionEl, selectedAnswer):
Stops the timer.
Disables all options to prevent multiple selections.
Checks if the selectedAnswer is correct.
Applies correct or wrong CSS classes to the selected option and highlights the correct answer.
Calculates points based on timeLeft for correct answers.
Updates score, correctAnswers, wrongAnswers.
Displays immediate feedback.
Proceeds to the next question after a delay.
endQuiz(): Transitions to the results screen, updates result statistics, and emits the final score to the server via emitGameEnd().
updateLeaderboardUI(serverLeaderboard): A shared function used to render the leaderboard received from the server. It clears the existing leaderboard and dynamically creates new leaderboard-item elements.
Event Listeners:
startQuizBtn: Triggers initQuiz() and emits player_join to the server.
viewLeaderboardBtn: Toggles the visibility of the live leaderboard and requests an update from the server via get_leaderboard.
play-again-btn: Resets the UI to the login screen.
Socket.IO Event Handlers (Client-side):
socket.on("connect", ...): Logs connection status.
socket.on("player_joined", ...): Logs when another player joins.
socket.on("leaderboard_update", updateLeaderboardUI): Receives leaderboard data from the server and updates the UI.
main.py (Backend)
Flask and Socket.IO Setup:
Python

from flask import Flask
from flask_socketio import SocketIO, emit

app = Flask(__name__)
socketio = SocketIO(app, cors_allowed_origins=[...]) # CORS configuration
Initializes the Flask app and wraps it with Flask-SocketIO for WebSocket communication. cors_allowed_origins is crucial for security in web applications.
players List: A global list players = [] stores player data, including their name and score. This acts as the server-side representation of the leaderboard.
Socket.IO Event Handlers (Server-side):
@socketio.on("player_join"):
Triggered when a client emits a "player_join" event.
Adds the new player's name and an initial score of 0 to the players list.
Emits a "player_joined" broadcast to all connected clients, informing them of the new player.
@socketio.on("player_score"):
Triggered when a client finishes a quiz and emits their final score.
Updates the score for the specific player in the players list.
Sorts the players list by score in descending order to create the leaderboard.
Emits a "leaderboard_update" broadcast to all connected clients, sending the sorted leaderboard data.
@socketio.on("clear_leaderboard"):
A utility event to reset the server-side leaderboard.
Clears the players list.
Broadcasts an empty leaderboard update.
@socketio.on("get_leaderboard"):
Triggered when a client explicitly requests the current leaderboard (e.g., by clicking "View Leaderboard").
Sorts the players list.
Emits a "leaderboard_update" only to the requesting client (not a broadcast), sending the current leaderboard.
if __name__ == "__main__":: Runs the Flask-SocketIO application.
game_questions.yml (Content)
This YAML file serves as the data source for quiz questions. It's designed for easy readability and modification by non-developers, making content updates straightforward. The structure ensures that each question has its text, a list of options, and a clearly defined correct answer.

8. Socket.IO Events
Client-to-Server Events
player_join:
Purpose: Informs the server that a new player has joined the game.
Data: { name: "PlayerName" }
player_score:
Purpose: Sends a player's final score to the server after completing a quiz.
Data: { name: "PlayerName", score: 1234 }
get_leaderboard:
Purpose: Requests the current leaderboard from the server.
Data: None
Server-to-Client Events
player_joined:
Purpose: Broadcasts to all clients that a new player has joined.
Data: { name: "NewPlayerName" }
leaderboard_update:
Purpose: Broadcasts the updated sorted leaderboard to all clients (or emits to a single client if requested by get_leaderboard).
Data: [ { name: "Player1", score: 500 }, { name: "Player2", score: 450 }, ... ] (an array of player objects sorted by score).
9. Styling
The game.html includes an extensive <style> block that defines the visual presentation of the quiz. Key aspects include:

Glassmorphism: Achieved through background: rgba(...), backdrop-filter: blur(10px), border-radius, and box-shadow properties, creating a frosted glass effect for cards and elements.
Responsive Design: Media queries ensure the layout adjusts for smaller screens (e.g., mobile devices).
Animations: animate-fade class with a CSS @keyframes fadeIn provides smooth transitions for elements appearing on the page, enhancing user experience.
Color Palette: Uses a consistent cool-toned palette (#6C63FF, #f8fafc, #cbd5e1, etc.) for a modern and clean look.
Interactive Elements: Hover effects on buttons and options (transform: translateY(-2px), box-shadow) provide visual feedback.
Status Indicators: Specific classes (correct, wrong, selected, warning, danger) are used to visually highlight correct/incorrect answers and timer status.
10. Future Enhancements
Persistent Leaderboard: Save leaderboard data to a database (e.g., SQLite, PostgreSQL) instead of in-memory for persistence across server restarts.
Multiple Quiz Rooms: Allow teachers to create separate quiz rooms for different classes or topics.
Question Categories: Group questions by category or subject.
Admin Panel: A dedicated interface for teachers to manage questions, clear leaderboards, and monitor active games.
User Authentication: Implement user accounts for tracking individual student progress over time.
More Diverse Question Types: Add support for true/false, fill-in-the-blank, or short answer questions.
Sound Effects: Add audio cues for correct/wrong answers and timer warnings.
Difficulty Scaling per Question: Allow specific questions to have different point values or time limits.
Error Handling and Robustness: More comprehensive error handling for network issues or malformed data.

Sources










Deep Research

Canvas

# Lesson Feedback Poll Feature Documentation

This document details the "How was this lesson?" poll feature, which allows students to provide feedback on lessons using a simple thumbs-up/down mechanism, along with an optional text field for comments. The feedback is collected and visualized via Google Forms API and Google Sheets.

## Table of Contents

1.  [Introduction](#introduction)
2.  [Features](#features)
3.  [Technical Stack](#technical-stack)
4.  [Integration Steps](#integration-steps)
5.  [Usage](#usage)
    * [For Students](#for-students)
    * [For Teachers/Administrators](#for-teachersadministrators)
6.  [Code Explanation](#code-explanation)
    * [HTML Structure](#html-structure)
    * [CSS Styling](#css-styling)
    * [JavaScript Logic](#javascript-logic)
7.  [Google Forms & Sheets Setup](#google-forms--sheets-setup)
8.  [Customization](#customization)
9.  [Animations](#animations)
10. [Troubleshooting](#troubleshooting)

---

## 1. Introduction

The lesson feedback poll provides an easy way for students to offer quick insights into their learning experience. With a click, they can indicate if a lesson was helpful or not, and elaborate with optional text comments. This data is then automatically captured in a Google Sheet, offering teachers a live dashboard of student sentiment.

---

## 2. Features

* **Intuitive Feedback:** Simple thumbs-up and thumbs-down buttons for quick sentiment capture.
* **Optional Text Comments:** Allows students to provide detailed feedback.
* **Dynamic Form Display:** The comment form appears only after a thumb selection.
* **Submission Status:** Provides real-time feedback on submission success or failure.
* **Google Forms Integration:** Submits feedback directly to a pre-configured Google Form.
* **Google Sheets Data Visualization:** Displays a live, embedded Google Sheet for teachers to view feedback trends.
* **Loading Overlay:** A loading spinner and message are shown while the data dashboard loads.
* **Responsive Design:** Adapts to various screen sizes for optimal viewing on any device.
* **Animated UI:** Smooth transitions and hover effects enhance the user experience.

---

## 3. Technical Stack

* **Frontend:**
    * HTML5
    * CSS3 (inline styles and `<style>` block for animations)
    * JavaScript
    * Font Awesome (for icons)
* **Backend/Data Storage:**
    * Google Forms (for collecting feedback)
    * Google Sheets (for storing and visualizing feedback)

---

## 4. Integration Steps

To integrate this poll feature into your web page:

1.  **Copy the HTML and CSS:** Paste the entire provided HTML code block (including the inline `<style>` tag) into your `game.html` file or any other relevant HTML page where you want the poll to appear.
2.  **Add Font Awesome:** Ensure Font Awesome is linked in your HTML's `<head>` section for the icons to display correctly. If not already present, add:
    ```html
    <link rel="stylesheet" href="[https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css](https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css)">
    ```
3.  **Configure Google Form:**
    * **Create a Google Form:** Design a simple form with at least two fields:
        * A "Thumbs Up/Down" (short answer or multiple choice) field to capture 'up' or 'down' feedback.
        * A "Feedback Comment" (paragraph) field for optional text.
    * **Get Pre-filled URL:** You need to get the "pre-filled link" for your form. This is crucial for submitting data via JavaScript.
        * In your Google Form, go to the "Responses" tab (or directly create a pre-filled link).
        * Click the three dots (More options) -> "Get pre-filled link".
        * Fill in a dummy "up" and a dummy "down" value for your "Thumbs Up/Down" field.
        * Click "Get link" for each, and extract the `entry.XXXXXXXXX` IDs for your fields.
        * The JavaScript uses these IDs to send data.
    * **Update JavaScript `FORM_URL` and `FIELD_IDS`:** Modify the `FORM_URL` and `FIELD_IDS` variables in the provided JavaScript to match your Google Form's `formResponse` URL and the entry IDs for your feedback fields.
4.  **Publish Google Sheet for Web:**
    * **Link Form to Sheet:** Ensure your Google Form is linked to a Google Sheet (Form Responses tab).
    * **Publish Sheet:** In the Google Sheet, go to `File > Share > Publish to web`. Select the appropriate sheet (e.g., "Form Responses 1") and publish it as an HTML page.
    * **Update `iframe src`:** Copy the generated public URL and paste it into the `src` attribute of the `<iframe>` element in your HTML.
        ```html
        <iframe
          id="dataIframe"
          src="YOUR_PUBLISHED_GOOGLE_SHEET_URL"
          width="100%"
          height="500"
          frameborder="0"
          style="border: none; background: white; transition: opacity 0.3s ease;"
          onload="hideLoadingOverlay()">
        </iframe>
        ```

---

## 5. Usage

### For Students

1.  **Give Feedback:** On the lesson page, they'll see the "How was this lesson?" section.
2.  **Select Sentiment:** Click either the **👍 Thumbs Up** or **👎 Thumbs Down** button.
3.  **Add Comments (Optional):** A text box will appear. They can type in any additional thoughts.
4.  **Submit:** Click the "Submit Feedback" button. A status message will confirm their submission.
5.  **Reset:** If they want to change their feedback or clear the text, they can click "Reset."

### For Teachers/Administrators

1.  **View Data:** Click the **"View Response Data"** button. This will expand a section displaying a live view of the Google Sheet containing all feedback.
2.  **Monitor Trends:** Observe the aggregated data and individual comments in real-time.
3.  **Refresh Data:** Click the "Refresh Data" button to ensure the embedded sheet is showing the absolute latest submissions.

---

## 6. Code Explanation

### HTML Structure

The structure is designed for a visually appealing "glassmorphism" effect with gradient backgrounds and rounded corners.

* **`section-container`:** The main wrapper for the entire poll feature, providing a gradient background and initial styling.
* **Decorative Elements:** Absolutely positioned `div`s with radial gradients and `transform` properties create subtle visual flair.
* **`section-title`:** Displays the main question "How was this lesson?" with an icon and gradient text.
* **`section-content`:** The inner card for the feedback buttons and form, featuring a semi-transparent white background with blur (`backdrop-filter`).
* **`feedback-buttons`:** Contains the "Thumbs Up" and "Thumbs Down" buttons.
* **`feedbackForm`:** The `textarea` and submit/reset buttons, initially `display: none;`. It appears after a thumb button is clicked.
* **`feedbackStatus`:** Displays submission messages (e.g., "Feedback submitted successfully!").
* **`data-insights-section`:** The section for viewing the raw response data.
* **`dataToggle` button:** Toggles the visibility of the `dataContainer`.
* **`dataContainer`:** Houses the embedded Google Sheet iframe, with a loading overlay and header/footer for context.
* **`dataIframe`:** The `<iframe>` element that loads the published Google Sheet.
* **`loadingOverlay`:** An overlay that hides the iframe while it loads, showing a spinner.

### CSS Styling

Most CSS is inline for immediate visual impact and specific element styling. The `<style>` block at the end of the HTML contains keyframe animations and hover effects:

* **`@keyframes`:**
    * `fadeInUp`: For elements animating into view from below.
    * `pulse`: For the selected thumb button, creating a subtle pulsing effect.
    * `spin`: For the loading spinner.
    * `slideDown`: For the `dataContainer` when it expands.
* **`thumb-btn:hover`:** Adds a `transform` and `box-shadow` effect on hover, plus a linear gradient "shine" effect across the button.
* **`thumb-btn.selected`:** Applies the `pulse` animation and a stronger `box-shadow`.
* **`data-container.show`:** Controls the visibility and animation of the data dashboard.
* **`textarea:focus`:** Enhances the `textarea` when it's focused, changing its border and shadow.

### JavaScript Logic

The `<script>` tag at the end of the HTML (not provided but assumed to be present based on the `onclick` attributes) would contain the following:

* **`selectedFeedbackType`:** A variable to store whether 'up' or 'down' was selected.
* **`FORM_URL`:** The base URL for your Google Form's `formResponse` endpoint.
* **`FIELD_IDS`:** An object mapping feedback types to their respective Google Form `entry.XXXXXXXXX` IDs.
* **`selectFeedback(type)`:**
    * Removes `selected` class from all thumb buttons.
    * Adds `selected` class to the clicked button.
    * Sets `selectedFeedbackType`.
    * Updates the `feedbackTitle` text based on the selected type.
    * Displays the `feedbackForm` with an animation.
    * Hides any previous `feedbackStatus` messages.
* **`submitFeedback()`:**
    * Retrieves the `feedbackText` and `selectedFeedbackType`.
    * Constructs a `FormData` object with the appropriate `entry.XXXXXXXXX` IDs and values.
    * Uses `fetch()` to send a `POST` request to the Google Form's `formResponse` URL.
    * Displays success or error messages in `feedbackStatus`.
    * Resets the form after submission.
* **`resetFeedback()`:**
    * Clears the `selectedFeedbackType`.
    * Removes `selected` class from thumb buttons.
    * Clears the `feedbackText`.
    * Hides the `feedbackForm` and `feedbackStatus`.
* **`toggleDataView()`:**
    * Toggles the `show` class on `dataContainer` to expand/collapse the data view.
    * Rotates the chevron arrow icon (`toggle-arrow`).
    * Changes the text of the `dataToggle` button ("View Response Data" / "Hide Response Data").
* **`hideLoadingOverlay()`:** Hides the `loadingOverlay` once the iframe content has loaded.
* **`refreshData()`:** Reloads the `iframe` by resetting its `src` attribute, effectively refreshing the embedded Google Sheet.

---

## 7. Google Forms & Sheets Setup

This feature *requires* a correctly configured Google Form and a publicly published Google Sheet.

1.  **Create Google Form:**
    * Go to Google Forms.
    * Create a new form.
    * Add a **Short answer** or **Multiple choice** question for "How was this lesson?" (e.g., options: "Thumbs Up", "Thumbs Down").
    * Add a **Paragraph** question for "Additional Comments (Optional)".
    * **Crucially**, get the pre-filled URLs for each option to identify their unique `entry.XXXXXXXXX` IDs. For example, fill "Thumbs Up" in the first field, click "Get link," then parse the URL for its `entry.` ID. Do the same for "Thumbs Down." This allows the JavaScript to target the correct fields.
2.  **Link to Google Sheet:**
    * In your Google Form, click on "Responses," then click the green Google Sheets icon to create a new spreadsheet or link to an existing one. This sheet will store all your feedback.
3.  **Publish Google Sheet to Web:**
    * Open the linked Google Sheet.
    * Go to `File > Share > Publish to web`.
    * Select the sheet tab that contains your form responses (e.g., "Form Responses 1").
    * Choose "Web page" as the format.
    * Click "Publish."
    * Copy the generated URL. This URL is used in the `<iframe>`'s `src` attribute.

---

## 8. Customization

* **Colors & Gradients:** Modify the `background` and `linear-gradient` values in the inline styles to match your brand or preferred aesthetic.
* **Text:** Change the `section-title` and `feedbackTitle` texts directly in the HTML and JavaScript.
* **Icons:** Use different Font Awesome icons by changing the `<i>` tags.
* **Animation Timing:** Adjust `transition` and `animation-duration` values in the CSS to speed up or slow down animations.
* **Google Form/Sheet:** Update the `FORM_URL` and `FIELD_IDS` in the JavaScript and the `iframe src` in the HTML to point to your own Google Form and published Sheet.

---

## 9. Animations

The feature incorporates several animations for a dynamic and engaging user experience:

* **`animate-in`:** A general fade-in animation for the main container on page load.
* **`fadeInUp`:** Used when the feedback form or status message appears, giving a smooth upward transition.
* **`pulse`:** Applied to the selected "thumb" button, subtly drawing attention.
* **Shine Effects:** Linear gradients (`linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent)`) within the thumb buttons and submit button, combined with `left: -100%` to `left: 100%` transitions on hover, create a "shine" or "swipe" effect.
* **`spin`:** For the loading spinner while the iframe content loads.
* **`slideDown`:** When the "Response Data" section is toggled, it smoothly slides down into view.
* **Hover Effects:** Buttons and interactive elements have `transform: translateY` and `box-shadow` changes on hover for visual feedback.

---

## 10. Troubleshooting

* **Feedback Not Submitting:**
    * Double-check that the `FORM_URL` and `FIELD_IDS` in your JavaScript exactly match your Google Form's `formResponse` URL and entry IDs.
    * Ensure your Google Form is active and accepting responses.
    * Check your browser's developer console for any `fetch` errors.
* **Google Sheet Not Displaying:**
    * Verify that your Google Sheet is published to the web and that the `src` attribute of the `<iframe>` uses the *published* URL.
    * Ensure there are no restrictions on the Google Sheet preventing embedding.
    * Check your browser's developer console for `iframe` loading errors or security policy (`CSP`) issues if your site uses one.
* **Icons Not Showing:**
    * Confirm that the Font Awesome CSS link is correctly included in your HTML's `<head>`.
* **Animations Not Working:**
    * Check for typos in CSS class names or `@keyframes` definitions.
    * Ensure `transition` and `animation` properties are correctly applied.
    * Verify that `display: none;` and `display: block;` toggling is handled correctly for animated elements.






# Enhance Your Learning: A Guide to the Interactive Sidebar

This interactive sidebar is your all-in-one learning companion, designed to boost comprehension and personalize your study experience. Whether you're a student looking to deepen your understanding or a teacher guiding the learning process, this sidebar offers powerful tools right at your fingertips.

---

## 1. Navigating the Sidebar: Your Learning Hub

The sidebar lives on the left side of your screen, always accessible. It's home to several key features, each designed to support a different aspect of your learning journey:

* **📚 Dictionary:** Quickly look up unfamiliar words.
* **📝 Notes:** Take and manage personal notes linked to your lesson content.
* **🔊 Read Text:** Listen to selected text, perfect for auditory learners or review.
* **🎨 Highlight:** Mark important sections with custom colors and even add notes directly to them.

To open or close any of the associated panels (Dictionary or Notes), simply click on its respective icon in the sidebar.

---

## 2. Master New Vocabulary with the Dictionary

The dictionary feature makes clarifying new terms quick and easy.

### For Students:

1.  **Open the Dictionary:** Click the **📚 Dictionary** icon in the sidebar. A "Dictionary Lookup" window will appear.
2.  **Enter a Word:** Type the word you want to define into the input field labeled "Enter a word...".
3.  **Search:** Click the **"Search"** button or press **Enter** on your keyboard.
4.  **View Definition:** The definition, including part of speech and examples, will appear in the "Result" area.
5.  **Close:** Click the **"✖"** button in the top right corner of the dictionary window to close it. The search field and results will automatically clear, ready for your next lookup.

### For Teachers/Administrators:

* Encourage students to use this feature proactively when encountering new vocabulary.
* Suggest looking up key terms before or after a lesson to reinforce understanding.

---

## 3. Personalize Your Learning with Notes

The notes feature allows you to capture your thoughts and insights, keeping them organized and accessible.

### For Students:

1.  **Open the Notes Panel:** Click the **📝 Notes** icon in the sidebar. The "Your Notes" panel will slide open on the right side of the screen.
2.  **Add a New Note:**
    * Type your note into the "Add a new note..." text area.
    * Click the **"Add Note"** button. Your note will appear in the list above.
3.  **Edit an Existing Note:**
    * Find the note you wish to edit in the list.
    * Click the **"Edit"** button next to that note. The note's text will populate the text area.
    * Make your changes.
    * Click the **"Update Note"** button.
    * If you change your mind, click **"Cancel"** to revert.
4.  **Delete a Note:**
    * Locate the note you want to remove.
    * Click the **"Delete"** button next to it. Confirm your decision if prompted.
5.  **Notes Linked to Highlights:** If you add a note while highlighting text (see the "Highlight" section), the note will include context from the highlighted text. Click on the "Context" text within a note to **automatically scroll to the associated highlighted section** in your lesson content. This is a powerful way to review your notes in context!
6.  **Close the Notes Panel:** Click the **"✖"** button in the top right of the notes panel to close it. Your notes are automatically saved.

### For Teachers/Administrators:

* Recommend students use notes for summarizing key points, asking questions, or jotting down personal reflections.
* Suggest using the highlight-linked notes to encourage active reading and deeper engagement with specific parts of the lesson.
* Remind students that notes are saved locally in their browser, meaning they'll persist even if they close and reopen the page.

---

## 4. Listen and Learn with Read Text

The "Read Text" feature is ideal for auditory learners, for reviewing content, or when you simply prefer to listen.

### For Students:

1.  **Select Text:** Using your mouse, highlight the specific text within the main lesson content (`<div id="lesson-content">...</div>`) that you want to hear.
2.  **Activate Read Text:** Click the **🔊 Read Text** icon in the sidebar.
3.  **Listen:** The selected text will be read aloud.
4.  **Troubleshooting:** If no sound plays, ensure your device's volume is up and check your internet connection. If an alert appears, make sure you've selected text *within the main lesson content area*.

### For Teachers/Administrators:

* Advise students to use this feature to:
    * Review difficult passages.
    * Catch up if they missed class.
    * Enhance comprehension by engaging another sense (auditory).
    * Proofread their own writing by listening to it.
* Emphasize that a valid VoiceRSS API key is required for this feature to function (this is configured in the backend JavaScript).

---

## 5. Focus Your Study with the Highlight Feature

The highlight tool lets you visually mark important information and even attach notes directly to your highlights.

### For Students:

1.  **Activate Highlight Mode:** Click the **🎨 Highlight** icon in the sidebar.
    * A small **color picker** will appear next to the button.
    * Your mouse cursor will change to a **crosshair** when hovering over the lesson content, indicating highlight mode is active.
2.  **Choose a Color:** Click on the color picker and select your desired highlight color.
3.  **Highlight Text:** Click and drag your mouse over the text you want to highlight within the main lesson content. When you release the mouse button, the selected text will be highlighted in your chosen color.
4.  **Remove a Highlight:** Hover over a highlighted section. A small **"✖" (trash can) icon** will appear within the highlight. Click this icon to remove the highlight.
5.  **Add/Edit Note for a Highlight:** Hover over a highlighted section. A small **"📝" (note) icon** will appear.
    * Click this icon to **open the Notes panel**.
    * If no note exists for that highlight, a new note input will be pre-filled with context from the highlighted text, ready for you to add your thoughts.
    * If a note already exists, the existing note will be loaded into the editing area, allowing you to modify it.
    * Hovering over the "📝" icon for a highlighted section that *already has a note* will show a **pop-over preview** of that note, giving you a quick reminder without opening the full notes panel.
6.  **Deactivate Highlight Mode:** Click the **🎨 Highlight** icon again. The color picker will disappear, and your cursor will return to normal. This ensures you don't accidentally highlight text.

### For Teachers/Administrators:

* Encourage students to use highlighting to identify main ideas, supporting details, or vocabulary.
* Suggest using different highlight colors for different purposes (e.g., yellow for key terms, blue for questions).
* Demonstrate how the highlight-linked notes can create an active reading strategy, connecting visual cues directly to written reflections.
* Inform students that highlights and their associated notes are saved locally in their browser, so they don't lose their work.

---

This interactive sidebar is a powerful tool to enhance student engagement and comprehension. Encourage its regular use to make the most of your learning experience!




